{
    "50": {
        "language_from": "Python",
        "language_to": "Rust",
        "source_code": "'''Rust\nprint(\"Hello!\")'''"
    },

    "100": {
        "language_from": "Rust",
        "language_to": "Python",
        "source_code": "'''Rust\nfn main() {\n    let x = 5;\n    let x = x + 1;\n    let x = x * 2;\n    println!(\"The value of x is: {}\", x);\n}'''"
    },

    "500": {
        "language_from": "C++",
        "language_to": "Python",
        "source_code": "'''
    #include <iostream>
    #include <vector>
    #include <string>
    #include <algorithm>

    class Student {
    public:
        Student(std::string name, int age, std::vector<int> grades)
            : name(name), age(age), grades(grades) {}

        double average_grade() const {
            int sum = 0;
            for (int grade : grades) {
                sum += grade;
            }
            return static_cast<double>(sum) / grades.size();
        }

        void print_info() const {
            std::cout << "Name: " << name << ", Age: " << age << ", Average Grade: " 
                    << average_grade() << std::endl;
        }

    private:
        std::string name;
        int age;
        std::vector<int> grades;
    };

    int main() {
        std::vector<Student> students = {
            Student("Alice", 20, {85, 90, 78}),
            Student("Bob", 21, {88, 92, 80}),
            Student("Charlie", 19, {95, 89, 84}),
            Student("David", 22, {72, 85, 90}),
            Student("Eve", 20, {88, 76, 95}),
            Student("Frank", 24, {88, 76, 95})
        };

        std::sort(students.begin(), students.end(), [](const Student& a, const Student& b) {
            return a.average_grade() > b.average_grade();
        });

        for (const Student& student : students) {
            student.print_info();
        }

        return 0;
    }
    '''"
    },

    "1k": {
        "language_from": "Java",
        "language_to": "Python",
        "source_code": """
    import java.util.ArrayList;
    import java.util.Collections;
    import java.util.Comparator;
    import java.util.HashMap;
    import java.util.List;
    import java.util.Map;

    class Student {
        private String name;
        private int age;
        private List<Integer> grades;

        public Student(String name, int age, List<Integer> grades) {
            this.name = name;
            this.age = age;
            this.grades = grades;
        }

        public double averageGrade() {
            int sum = 0;
            for (int grade : grades) {
                sum += grade;
            }
            return (double) sum / grades.size();
        }

        public void printInfo() {
            System.out.printf("======== print info of %s =========", this.name);
            System.out.printf("Name: %s, Age: %d, Average Grade: %.2f\n", name, age, averageGrade());
        }

        public String getName() {
            return name;
        }

        public int getAge() {
            return age;
        }

        public List<Integer> getGrades() {
            return grades;
        }
    }

    public class Main {
        public static void main(String[] args) {
            List<Student> students = new ArrayList<>();
            students.add(new Student("Alice", 20, List.of(85, 90, 78)));
            students.add(new Student("Bob", 21, List.of(88, 92, 80)));
            students.add(new Student("Charlie", 19, List.of(95, 89, 84)));
            students.add(new Student("David", 22, List.of(72, 85, 90)));
            students.add(new Student("Eve", 20, List.of(88, 76, 95)));
            students.add(new Student("Frank", 23, List.of(91, 82, 88)));
            students.add(new Student("Grace", 21, List.of(79, 85, 87)));
            students.add(new Student("Heidi", 20, List.of(92, 91, 89)));
            students.add(new Student("Ivan", 22, List.of(84, 79, 85)));
            students.add(new Student("Judy", 23, List.of(75, 80, 78)));

            Collections.sort(students, Comparator.comparingDouble(Student::averageGrade).reversed());

            for (Student student : students) {
                student.printInfo();
            }

            printClassInfo(students);
        }

        public static void printClassInfo(List<Student> students) {
            Map<Integer, Integer> ageDistribution = new HashMap<>();
            double totalAverageGrade = 0.0;
            int totalGradesCount = 0;

            for (Student student : students) {
                ageDistribution.put(student.getAge(), ageDistribution.getOrDefault(student.getAge(), 0) + 1);
                totalAverageGrade += student.averageGrade() * student.getGrades().size();
                totalGradesCount += student.getGrades().size();
            }
            totalAverageGrade /= totalGradesCount;

            System.out.printf("Class Average Grade: %.2f\n", totalAverageGrade);
            System.out.println("Age Distribution:");
            for (Map.Entry<Integer, Integer> entry : ageDistribution.entrySet()) {
                System.out.printf("Age %d: %d students\n", entry.getKey(), entry.getValue());
            }
        }
    }
    """
    },

    "2k": {
        "language_from": "Python",
        "language_to": "Java",
        "source_code": """
    import random
    import string
    import math
    from collections import Counter
    from itertools import permutations
    from functools import lru_cache

    # Function to generate a random string of fixed length
    def generate_random_string(length):
        return ''.join(random.choices(string.ascii_letters + string.digits, k=length))

    # Function to calculate factorial
    def factorial(n):
        if n == 0 or n == 1:
            return 1
        else:
            return n * factorial(n - 1)

    # Function to compute the n-th Fibonacci number using memoization
    @lru_cache(maxsize=None)
    def fibonacci(n):
        if n < 0:
            raise ValueError("Input should be a non-negative integer")
        elif n == 0:
            return 0
        elif n == 1:
            return 1
        else:
            return fibonacci(n - 1) + fibonacci(n - 2)

    # Function to calculate the Euclidean distance between two points in 3D space
    def euclidean_distance(point1, point2):
        if len(point1) != 3 or len(point2) != 3:
            raise ValueError("Both points must have three coordinates")
        return math.sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2 + (point1[2] - point2[2]) ** 2)

    # Function to count the frequency of each character in a string
    def char_frequency(input_string):
        return dict(Counter(input_string))

    # Function to generate all permutations of a list
    def generate_permutations(input_list):
        return list(permutations(input_list))

    # Function to check if a string is a palindrome
    def is_palindrome(s):
        return s == s[::-1]

    # Function to find the greatest common divisor (GCD) of two numbers
    def gcd(a, b):
        while b:
            a, b = b, a % b
        return a

    # Function to perform a binary search on a sorted list
    def binary_search(arr, target):
        low, high = 0, len(arr) - 1
        while low <= high:
            mid = (low + high) // 2
            if arr[mid] == target:
                return mid
            elif arr[mid] < target:
                low = mid + 1
            else:
                high = mid - 1
        return -1

    # Function to compute the area of a circle given its radius
    def circle_area(radius):
        if radius < 0:
            raise ValueError("Radius cannot be negative")
        return math.pi * radius ** 2

    # Function to sort a list using quicksort algorithm
    def quicksort(arr):
        if len(arr) <= 1:
            return arr
        pivot = arr[len(arr) // 2]
        left = [x for x in arr if x < pivot]
        middle = [x for x in arr if x == pivot]
        right = [x for x in arr if x > pivot]
        return quicksort(left) + middle + quicksort(right)

    # Function to find the longest common subsequence (LCS) of two strings
    def lcs(X, Y):
        m = len(X)
        n = len(Y)
        L = [[None] * (n + 1) for i in range(m + 1)]
        for i in range(m + 1):
            for j in range(n + 1):
                if i == 0 or j == 0:
                    L[i][j] = 0
                elif X[i - 1] == Y[j - 1]:
                    L[i][j] = L[i - 1][j - 1] + 1
                else:
                    L[i][j] = max(L[i - 1][j], L[i][j - 1])
        return L[m][n]

    # Function to generate a list of prime numbers up to a given limit
    def sieve_of_eratosthenes(limit):
        primes = [True] * (limit + 1)
        p = 2
        while (p * p <= limit):
            if (primes[p] == True):
                for i in range(p * p, limit + 1, p):
                    primes[i] = False
            p += 1
        return [p for p in range(2, limit + 1) if primes[p]]

    # Function to perform matrix multiplication
    def matrix_multiply(A, B):
        if len(A[0]) != len(B):
            raise ValueError("Number of columns in A must be equal to number of rows in B")
        result = [[sum(x * y for x, y in zip(A_row, B_col)) for B_col in zip(*B)] for A_row in A]
        return result

    # Function to compute the dot product of two vectors
    def dot_product(vector1, vector2):
        if len(vector1) != len(vector2):
            raise ValueError("Vectors must be of same length")
        return sum(x * y for x, y in zip(vector1, vector2))

    # Function to perform a depth-first search (DFS) in a graph
    def dfs(graph, start, visited=None):
        if visited is None:
            visited = set()
        visited.add(start)
        for next in graph[start] - visited:
            dfs(graph, next, visited)
        return visited

    # Function to perform a breadth-first search (BFS) in a graph
    def bfs(graph, start):
        visited, queue = set(), [start]
        while queue:
            vertex = queue.pop(0)
            if vertex not in visited:
                visited.add(vertex)
                queue.extend(graph[vertex] - visited)
        return visited

    # Function to compute the edit distance between two strings
    def edit_distance(str1, str2):
        m = len(str1)
        n = len(str2)
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        for i in range(m + 1):
            for j in range(n + 1):
                if i == 0:
                    dp[i][j] = j
                elif j == 0:
                    dp[i][j] = i
                elif str1[i - 1] == str2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1]
                else:
                    dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])
        return dp[m][n]

    def is_perfect_square(n):
        return n == int(math.sqrt(n)) ** 2

    # Function to compute the power of a number using recursion
    def power(base, exp):
        if exp == 0:
            return 1
        elif exp % 2 == 0:
            half = power(base, exp // 2)
            return half * half
        else:
            return base * power(base, exp - 1)

    # Function to merge two sorted lists
    def merge_sorted_lists(list1, list2):
        sorted_list = []
        i = j = 0
        while i < len(list1) and j < len(list2):
            if list1[i] < list2[j]:
                sorted_list.append(list1[i])
                i += 1
            else:
                sorted_list.append(list2[j])
                j += 1
        sorted_list.extend(list1[i:])
        sorted_list.extend(list2[j:])
        return sorted_list
    """
    },

    "3k": {
        "language_from": "Python",
        "language_to": "Java",
        "source_code": """
    import random
    import string
    import math
    from collections import Counter
    from itertools import permutations
    from functools import lru_cache

    # Function to generate a random string of fixed length
    def generate_random_string(length):
        return ''.join(random.choices(string.ascii_letters + string.digits, k=length))

    # Function to calculate factorial
    def factorial(n):
        if n == 0 or n == 1:
            return 1
        else:
            return n * factorial(n - 1)

    # Function to compute the n-th Fibonacci number using memoization
    @lru_cache(maxsize=None)
    def fibonacci(n):
        if n < 0:
            raise ValueError("Input should be a non-negative integer")
        elif n == 0:
            return 0
        elif n == 1:
            return 1
        else:
            return fibonacci(n - 1) + fibonacci(n - 2)

    # Function to calculate the Euclidean distance between two points in 3D space
    def euclidean_distance(point1, point2):
        if len(point1) != 3 or len(point2) != 3:
            raise ValueError("Both points must have three coordinates")
        return math.sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2 + (point1[2] - point2[2]) ** 2)

    # Function to count the frequency of each character in a string
    def char_frequency(input_string):
        return dict(Counter(input_string))

    # Function to generate all permutations of a list
    def generate_permutations(input_list):
        return list(permutations(input_list))

    # Function to check if a string is a palindrome
    def is_palindrome(s):
        return s == s[::-1]

    # Function to find the greatest common divisor (GCD) of two numbers
    def gcd(a, b):
        while b:
            a, b = b, a % b
        return a

    # Function to perform a binary search on a sorted list
    def binary_search(arr, target):
        low, high = 0, len(arr) - 1
        while low <= high:
            mid = (low + high) // 2
            if arr[mid] == target:
                return mid
            elif arr[mid] < target:
                low = mid + 1
            else:
                high = mid - 1
        return -1

    # Function to compute the area of a circle given its radius
    def circle_area(radius):
        if radius < 0:
            raise ValueError("Radius cannot be negative")
        return math.pi * radius ** 2

    # Function to sort a list using quicksort algorithm
    def quicksort(arr):
        if len(arr) <= 1:
            return arr
        pivot = arr[len(arr) // 2]
        left = [x for x in arr if x < pivot]
        middle = [x for x in arr if x == pivot]
        right = [x for x in arr if x > pivot]
        return quicksort(left) + middle + quicksort(right)

    # Function to find the longest common subsequence (LCS) of two strings
    def lcs(X, Y):
        m = len(X)
        n = len(Y)
        L = [[None] * (n + 1) for i in range(m + 1)]
        for i in range(m + 1):
            for j in range(n + 1):
                if i == 0 or j == 0:
                    L[i][j] = 0
                elif X[i - 1] == Y[j - 1]:
                    L[i][j] = L[i - 1][j - 1] + 1
                else:
                    L[i][j] = max(L[i - 1][j], L[i][j - 1])
        return L[m][n]

    # Function to generate a list of prime numbers up to a given limit
    def sieve_of_eratosthenes(limit):
        primes = [True] * (limit + 1)
        p = 2
        while (p * p <= limit):
            if (primes[p] == True):
                for i in range(p * p, limit + 1, p):
                    primes[i] = False
            p += 1
        return [p for p in range(2, limit + 1) if primes[p]]

    # Function to perform matrix multiplication
    def matrix_multiply(A, B):
        if len(A[0]) != len(B):
            raise ValueError("Number of columns in A must be equal to number of rows in B")
        result = [[sum(x * y for x, y in zip(A_row, B_col)) for B_col in zip(*B)] for A_row in A]
        return result

    # Function to compute the dot product of two vectors
    def dot_product(vector1, vector2):
        if len(vector1) != len(vector2):
            raise ValueError("Vectors must be of same length")
        return sum(x * y for x, y in zip(vector1, vector2))

    # Function to perform a depth-first search (DFS) in a graph
    def dfs(graph, start, visited=None):
        if visited is None:
            visited = set()
        visited.add(start)
        for next in graph[start] - visited:
            dfs(graph, next, visited)
        return visited

    # Function to perform a breadth-first search (BFS) in a graph
    def bfs(graph, start):
        visited, queue = set(), [start]
        while queue:
            vertex = queue.pop(0)
            if vertex not in visited:
                visited.add(vertex)
                queue.extend(graph[vertex] - visited)
        return visited

    # Function to compute the edit distance between two strings
    def edit_distance(str1, str2):
        m = len(str1)
        n = len(str2)
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        for i in range(m + 1):
            for j in range(n + 1):
                if i == 0:
                    dp[i][j] = j
                elif j == 0:
                    dp[i][j] = i
                elif str1[i - 1] == str2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1]
                else:
                    dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])
        return dp[m][n]

    # Function to check if a number is a perfect square
    def is_perfect_square(n):
        return n == int(math.sqrt(n)) ** 2

    # Function to compute the power of a number using recursion
    def power(base, exp):
        if exp == 0:
            return 1
        elif exp % 2 == 0:
            half = power(base, exp // 2)
            return half * half
        else:
            return base * power(base, exp - 1)

    # Function to merge two sorted lists
    def merge_sorted_lists(list1, list2):
        sorted_list = []
        i = j = 0
        while i < len(list1) and j < len(list2):
            if list1[i] < list2[j]:
                sorted_list.append(list1[i])
                i += 1
            else:
                sorted_list.append(list2[j])
                j += 1
        sorted_list.extend(list1[i:])
        sorted_list.extend(list2[j:])
        return sorted_list

    # Function to count the number of vowels in a string
    def count_vowels(s):
        vowels = "aeiouAEIOU"
        return sum(1 for char in s if char in vowels)

    # Function to reverse the words in a string
    def reverse_words(s):
        return ' '.join(s.split()[::-1])

    # Function to convert a decimal number to binary
    def decimal_to_binary(n):
        return bin(n).replace("0b", "")

    # Function to check if two strings are anagrams
    def are_anagrams(str1, str2):
        return Counter(str1) == Counter(str2)

    # Function to find the longest increasing subsequence in an array
    def longest_increasing_subsequence(arr):
        if not arr:
            return []
        dp = [1] * len(arr)
        for i in range(1, len(arr)):
            for j in range(i):
                if arr[i] > arr[j]:
                    dp[i] = max(dp[i], dp[j] + 1)
        length = max(dp)
        lis = []
        for i in range(len(dp) - 1, -1, -1):
            if dp[i] == length:
                lis.append(arr[i])
                length -= 1
        return lis[::-1]

    # Function to generate Pascal's triangle up to n rows
    def generate_pascals_triangle(n):
        triangle = []
        for i in range(n):
            row = [1] * (i + 1)
            for j in range(1, i):
                row[j] = triangle[i - 1][j - 1] + triangle[i - 1][j]
            triangle.append(row)
        return triangle

    # Function to perform matrix transposition
    def transpose_matrix(matrix):
        return list(map(list, zip(*matrix)))

    # Function to check if a number is a prime
    def is_prime(n):
        if n <= 1:
            return False
        for i in range(2, int(math.sqrt(n)) + 1):
            if n % i == 0:
                return False
        return True

    # Function to find the maximum subarray sum using Kadane's algorithm
    def max_subarray_sum(arr):
        max_so_far = arr[0]
        max_ending_here = arr[0]
        for i in range(1, len(arr)):
            max_ending_here = max(arr[i], max_ending_here + arr[i])
            max_so_far = max(max_so_far, max_ending_here)
        return max_so_far

    # Function to calculate the sum of the digits of a number
    def sum_of_digits(n):
        return sum(int(digit) for digit in str(n))

    # Function to find the median of two sorted arrays
    def find_median_sorted_arrays(nums1, nums2):
        nums = sorted(nums1 + nums2)
        length = len(nums)
        if length % 2 == 0:
            return (nums[length // 2 - 1] + nums[length // 2]) / 2
        else:
            return nums[length // 2]

    if __name__ == "__main__":
        array1 = [1, 3, 5, 7, 9]
        array2 = [2, 4, 6, 8, 10]
        median = find_median_sorted_arrays(array1, array2)
        print(f"Sorted array1: {array1}")
        print(f"Sorted array2: {array2}")
        print(f"Median of two sorted arrays is {median}.")
        sum = sum_of_digits(18234)
        print(f"Sum of digits of 18234 is {sum}")
    """
    }
}
